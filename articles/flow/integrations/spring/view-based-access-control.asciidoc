---
title: View Based Access Control
order: 25
layout: page
---

= View-Based Access Control

Vaadin Flow applications can use a view-based Access Control mechanism out of the box.
If an application is based on Spring Boot, this mechanism can be enabled by using a set of annotations and with minimum Spring Security configurations.
However, it is also possible to use it in Vaadin Spring applications that are not based on Spring Boot with some extra configurations.

== Introduction

Protecting restricted views in Spring based Vaadin Flow applications can happen through the following ways:

- By using Spring Security's URL pattern based HTTP security configurations
- By adding View-Based Access Control mechanism

As by navigating between routes of a Vaadin Flow application there would not be traditional page requests to the server, checking the authorized access to views using only Spring Security URL based filtering mechanism would be equal to only securing the first requested route, or simply no Security for the views at all, except for the first requested path.
This happens generally for any single page application that tries to secure its routes only using Spring Security.

.Do not rely on Spring Security's URL based authorization in Single Page Applications
[NOTE]
It is important to note that this View Based Access Control should be considered as the main mechanism of restricting access to the views.
The traditional Spring Security's URL-based [classname]#HttpSecurity# configurations should not be considered as the security mechanism for securing the views at all, except for the static resources as there is no way to load them other than URLs.


*This is where View Based Access Control comes in*, to fully securing the views of Vaadin Flow applications based on different access level annotations in a very flexible way.
The view-based Access Control mechanism uses the `@AnonymousAllowed`, `@PermitAll`, `@RolesAllowed`, and `@DenyAll` annotations on view classes to define the access control rules.

.Use of the annotations in Vaadin Fusion
[TIP]
Although, the same set of annotations are used to define the security access control rules on endpoints of a <<{articles}/fusion/overview#,Vaadin Fusion>> application, this document should not be considered as the way of securing client side views.
You can find out more about Security in a Vaadin Fusion application <<{articles}/fusion/security/configuring#,here>>.

The approach of the <<View Based Access Control in Spring Boot Based Applications,first part of this documentation>> is based on Vaadin's Spring Boot and Spring Security autoconfiguration.
If you are not using Spring Boot in your Vaadin Flow application, you may need extra configurations to enable this Access Control mechanism, that are addressed in <<View Based Access Control in Spring Based Applications>> (without Spring Boot).

== View Based Access Control in Spring Boot Based Applications

As mentioned in the <<Introduction,Introduction>>, the mechanism is based on Spring Security and Vaadin's Spring Boot autoconfiguration.
To enable the mechanism in a Vaadin Flow Spring Boot application without any security, the following should be added to the project (if not exist already):

- A Login view.
- Spring Security dependencies.
- A security configuration class that extends `VaadinWebSecurityConfigurerAdapter`.
- Annotating the view classes with `@AnonymousAllowed`, `@PermitAll`, or `@RolesAllowed` annotations.

.Source for the complete example code
[TIP]
A complete example project including the source codes of this documentation is available https://github.com/vaadin-learning-center/crm-tutorial/tree/latest[here].

=== Login View

Having a login view is one of the basic requirements of many authentication and authorization mechanisms to be able to redirect the anonymous users to that page before giving the access of viewing any protected resources.

.`LoginView.java`
[source,java]
----
@Route("login")
@PageTitle("Login")
public class LoginView extends VerticalLayout implements BeforeEnterObserver {

    LoginForm login = new LoginForm();

    public LoginView() {
        addClassName("login-view");
        setSizeFull();

        setJustifyContentMode(JustifyContentMode.CENTER);
        setAlignItems(Alignment.CENTER);

        login.setAction("login");

        add(
            new H1("Test Application"),
            login
        );
    }

    @Override
    public void beforeEnter(BeforeEnterEvent beforeEnterEvent) {
        if(beforeEnterEvent.getLocation()
        .getQueryParameters()
        .getParameters()
        .containsKey("error")) {
            login.setError(true);
        }
    }
}
----

.Usage of Vaadin's LoginForm Component
[NOTE]
In this example, Vaadin's `LoginForm` component is used to make the implementation more brief, but there is no obligation to do so, feel free to implement your own Login view, as you wish.

=== Spring Security Dependencies

To enable Spring Security in a Spring Boot application there are certain dependencies that should be added to the project.
_As this part of the documentation is based on a Spring Boot project, adding the following dependency is recommended_:

.Spring Boot Starter Security dependency that should be added to `pom.xml` file:
[source,XML]
----
<dependencies>
    <!-- other dependencies -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <!-- other dependencies -->
</dependencies>
----

=== Security Configuration Class

Next step is to have a Spring Security Configuration class that extends `VaadinWebSecurityConfigurerAdapter`.
No convention exists for naming this class, so in this documentation it is named as `SecurityConfiguration`, but pay attention to Spring Security annotations.
A minimal implementation of such class is as follows:

.`SecurityConfiguration.java`
[source,java]
----
@EnableWebSecurity
@Configuration
public class SecurityConfiguration extends VaadinWebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Delegating the responsibility of general configurations
        // of http security to the super class. It is configuring
        // the followings: Vaadin's CSRF protection by ignoring
        // framework's internal requests, default request cache,
        // ignoring public views annotated with @AnonymousAllowed,
        // restricting access to other views/endpoints, and enabling
        // ViewAccessChecker authorization.
        // You can add any possible extra configurations of your own
        // here (the following is just an example):

        // http.rememberMe().alwaysRemember(false);

        super.configure(http);

        // This is important to register your login view to the
        // view access checker mechanism:
        setLoginView(http, LoginView.class);
    }

    /**
     * Allows access to static resources, bypassing Spring security.
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        // Configure your static resources with public access here:
        web.ignoring().antMatchers(
                "/images/**"
        );

        // Delegating the ignoring configuration for Vaadin's
        // related static resources to the super class:
        super.configure(web);
    }

    /**
     * Demo UserDetailService which only provide two hardcoded
     * in memory users and their roles.
     * NOTE: This should not be used in real world applications.
     */
    @Bean
    @Override
    public UserDetailsService userDetailsService() {
        UserDetails user =
                User.withUsername("user")
                        .password("{noop}user")
                        .roles("USER")
                        .build();
        UserDetails admin =
                User.withUsername("admin")
                        .password("{noop}admin")
                        .roles("ADMIN")
                        .build();
        return new InMemoryUserDetailsManager(user, admin);
    }
}
----

Before going any further it worth noticing the presence of `@EnableWebSecurity` and `@Configuration` on top of the above class.
As their name imply, they tell the Spring to enable its security features.

Next thing to notice is the parent class: `VaadinWebSecurityConfigurerAdapter`.
As you might be familiar with Spring Boot and Spring Security, you may have seen that you can extend Spring's `WebSecurityConfigurerAdapter` directly and configure a lot of things from scratch, but by extending from `VaadinWebSecurityConfigurerAdapter` there would be some benefits:

- Default implementation of `configure` methods would take care of all the Vaadin related configurations, for example ignoring the static resources, or to enable the `CSRF` checking while ignoring the unnecessary checking for Vaadin internal requests, etc.
- The View Based Access Control mechanism is enabled by default.
- The login view can be configured simply via provided method `setLoginView`.

.Never use hard-coded credentials in production
[NOTE]
By looking at the implementation of `userDetailsService` method, it is obvious that this is just an in-memory implementation for the sake of briefness in this documentation.
In a real-world application You can change the Spring Security configuration to use an authentication provider for LDAP, JAAS, and other real world sources. https://dzone.com/articles/spring-security-authentication[Read more about Spring Security authentication providers].

The most important configuration in the above example, is the call to the `setLoginView(http, LoginView.class);` inside the first configure method.
This is how the view based Access Control mechanism knows where to redirect the users once they attempt to navigate to a protected view.

Now that the `LoginView` is ready, and it is set as the login view in the security configuration, it is time to move forward and see how the security annotations work on the views.

=== Annotating the View Classes

Before providing a usage examples of the access annotations, it would be beneficial to have a closer look at the annotations, and their meaning when applied on a view:

- `@AnonymousAllowed` Permits anyone to navigate to the view without any authentication or authorization.
- `@PermitAll` Allows any *authenticated* user to navigate to the view.
- `@RolesAllowed` Grants access to users having the roles specified in the annotation value.
- `@DenyAll` Disallows to navigate to the view for everyone.
This is the default, which means if a view is not annotated at all, the `@DenyAll` logic would be applied.

This should be highlighted that when the security configuration class is extending from `VaadinWebSecurityConfigurerAdapter`, Vaadin's `SpringSecurityAutoConfiguration` would come into play and *enables the View Based Access Control* mechanism.
Therefore, none of the views are accessible, until one of the above annotations (except the `@DenyAll`) is applied to them.

Some examples:

.Example of using @AnonymousAllowed to enable all users navigating to this view
[source,java]
----
@Route(value = "", layout = MainView.class)
@PageTitle("Public View")
@AnonymousAllowed
public class PublicView extends VerticalLayout {
    // ...
}
----

.Example of using @PermitAll to allow only authenticated users (with any role) navigating to this view
[source,java]
----
@Route(value = "private", layout = MainView.class)
@PageTitle("Private View")
@PermitAll
public class PrivateView extends VerticalLayout {
    // ...
}
----

.Example of using @RolesAllowed to enable only the users with `ADMIN` role navigating to this view
[source,java]
----
@Route(value = "admin", layout = MainView.class)
@PageTitle("Admin View")
@RolesAllowed("ADMIN") // <- Should match one of the user's roles (case-sensitive)
public class AdminView extends VerticalLayout {
    // ...
}
----

If multiple annotations specified on a single view, the following rules are applied:

- `DenyAll` overrides other annotations
- `AnonymousAllowed` overrides `RolesAllowed` and `PermitAll`
- `RolesAllowed` overrides `PermitAll`

However, specifying more than one of the above access annotations on a view class in not recommended, as it is confusing and probably has no logical reason to do so.

== View Based Access Control in Spring Based Applications

The configuration steps for a Vaadin Flow Spring application would be quite similar to some steps of the Vaadin Flow application which is based on Spring Boot.

- The application obviously should have a login view, an example login view can be found <<Login View,here>>.

- The Spring Security dependencies are as follows:

.Direct Spring Security dependencies that should be added to `pom.xml` file:
[source,XML]
----
<dependencies>
    <!-- other dependencies -->
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-config</artifactId>
    </dependency>
    <!-- other dependencies -->
</dependencies>
----

- A security configuration class that extends `VaadinWebSecurityConfigurerAdapter`.
This would be quite similar to the <<Security Configuration Class,Security Configuration Class>> example for a Vaadin Flow application based on Spring Boot.

- Some extra steps
//TODO: provide extra steps for a Spring based application

- Annotating the view classes with `@AnonymousAllowed`, `@PermitAll`, or `@RolesAllowed` annotations.
Again, this is completely similar to the <<Annotating the View Classes,provided examples>> for a Vaadin Flow application based on Spring Boot.

== Limitations
Mixing any of the view access annotations with Spring's URL based HTTP security (which probably are existing in older Vaadin Spring Boot applications) may result in unwanted access configurations or unnecessary complications.

.Do not mix Spring's URL based HTTP security and View based Access Control on a single view
[NOTE]
Vaadin strongly recommends *not* to mix Spring's URL Pattern based HTTP security and this View-based Access Control mechanism targeting same views, since it may lead to unwanted access configurations, or at least an unnecessary complication in the authorization of the views.
