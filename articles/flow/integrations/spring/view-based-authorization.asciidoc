---
title: View Based Authorization
order: 25
layout: page
---

= View Based Authorization

Vaadin applications that are based on Spring Boot, can leverage from a view based authorization mechanism out of the box, which can be enabled by using a set of annotations and with minimum Spring Security configurations.

== Introduction

At a glance, this mechanism is based on using `@AnonymousAllowed`, `@PermitAll`, `@RolesAllowed`, and `@DenyAll` annotations on view classes to define the access control rules.
This approach is also based on Vaadin's Spring Boot and Spring Security Auto-Configuration.
If you are not using Spring Boot in your Vaadin Flow application, you may need extra configurations to enable this authorization mechanism. `??? the last sentence needs further discussions`

.Vaadin Fusion Tip:
[TIP]
The same set of annotations are used to define the security access control rules on the endpoints of a <<{articles}/fusion/overview#,Vaadin Fusion>> application.
You can find out more about Security in a Vaadin Fusion application <<{articles}/fusion/security/configuring#,here>>.

.Where to Find the Source Codes
[TIP]
A complete example project containing the source codes of this documentation is available https://github.com/vaadin-learning-center/crm-tutorial/tree/latest[here].

== Adding View Based Access Control

As mention in the <<Introduction,Introduction>>, this mechanism is based on Spring Security and Vaadin's Spring Boot Auto-Configuration.
To enable this mechanism in a Vaadin Flow Spring Boot application without any security, the followings should be added to the project (if not exist already):

- A Login view.
- Spring Security dependencies.
- A security configuration class that extends `VaadinWebSecurityConfigurerAdapter`.
- Annotating the view classes with `@AnonymousAllowed`, `@PermitAll`, or `@RolesAllowed` annotations.

=== Login View

Having a login view is one of the basic requirements of many authentication and authorization mechanisms to be able to redirect the anonymous users to that page before giving the access of viewing any protected resources.

.`LoginView.java`
[source,java]
----
@Route("login")
@PageTitle("Login")
public class LoginView extends VerticalLayout implements BeforeEnterObserver {

    LoginForm login = new LoginForm();

    public LoginView() {
        addClassName("login-view");
        setSizeFull();

        setJustifyContentMode(JustifyContentMode.CENTER);
        setAlignItems(Alignment.CENTER);

        login.setAction("login");

        add(
            new H1("Test Application"),
            login
        );
    }

    @Override
    public void beforeEnter(BeforeEnterEvent beforeEnterEvent) {
        if(beforeEnterEvent.getLocation()
        .getQueryParameters()
        .getParameters()
        .containsKey("error")) {
            login.setError(true);
        }
    }
}
----

.Usage of Vaadin's LoginForm Component
[NOTE]
In this example, Vaadin's `LoginForm` component is used to make the implementation more brief, but there is no obligation to do so, feel free to implement your own Login view, as you wish.

=== Spring Security Dependencies

To enable Spring Security in a Spring Boot application there are certain dependencies that should be added to the project.
Either of the following ways can be used for adding Spring Security dependencies to the project.
_As this documentation is based on a Spring Boot project, the first way is recommended_:

.Spring Boot dependency that should be added to `pom.xml` file:
[source,XML]
----
<dependencies>
    <!-- other dependencies -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <!-- other dependencies -->
</dependencies>
----

Or

.Direct security dependencies that should be added to `pom.xml` file:
[source,XML]
----
<dependencies>
    <!-- other dependencies -->
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-config</artifactId>
    </dependency>
    <!-- other dependencies -->
</dependencies>
----

.Choose only one of the above ways to add Spring Security
[NOTE]
The above ways are two alternative way of adding Spring Security dependencies to the `pom.xml` file.
Do not duplicate the dependencies by trying both of them at the same time.

=== Security Configuration Class

Next step is to have a Spring Security Configuration class that extends `VaadinWebSecurityConfigurerAdapter`.
No convention exists for naming this class, so in this documentation it is named as `SecurityConfiguration`, but pay attention to Spring Security annotations.
A minimal implementation of such class is as follows:

.`SecurityConfiguration.java`
[source,java]
----
@EnableWebSecurity
@Configuration
public class SecurityConfiguration extends VaadinWebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Delegating the responsibility of general configurations
        // of http security to the super class. It is configuring
        // the followings: Vaadin's CSRF protection by ignoring
        // framework's internal requests, default request cache,
        // ignoring public views annotated with @AnonymousAllowed,
        // restricting access to other views/endpoints, and enabling
        // ViewAccessChecker authorization.
        // You can add any possible extra configurations of your own
        // here (the following is just an example):

        // http.rememberMe().alwaysRemember(false);

        super.configure(http);

        // This is important to register your login view to the
        // view access checker mechanism:
        setLoginView(http, LoginView.class);
    }

    /**
     * Allows access to static resources, bypassing Spring security.
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        // Configure your static resources with public access here:
        web.ignoring().antMatchers(
                "/images/**"
        );

        // Delegating the ignoring configuration for Vaadin's
        // related static resources to the super class:
        super.configure(web);
    }

    /**
     * Demo UserDetailService which only provide two hardcoded
     * in memory users and their roles.
     * NOTE: This should not be used in real world applications.
     */
    @Bean
    @Override
    public UserDetailsService userDetailsService() {
        UserDetails user =
                User.withUsername("user")
                        .password("{noop}user")
                        .roles("USER")
                        .build();
        UserDetails admin =
                User.withUsername("admin")
                        .password("{noop}admin")
                        .roles("ADMIN")
                        .build();
        return new InMemoryUserDetailsManager(user, admin);
    }
}
----

Before going any further it worth noticing the presence of `@EnableWebSecurity` and `@Configuration` on top of the above class.
As their name imply, they tell the Spring to enable its security features.

Next thing to notice is the parent class: `VaadinWebSecurityConfigurerAdapter`.
As you might be familiar with Spring Boot and Spring Security, you may have seen that you can extend Spring's `WebSecurityConfigurerAdapter` directly and configure a lot of things from scratch, but by extending from `VaadinWebSecurityConfigurerAdapter` there would be some benefits:

- Default implementation of `configure` methods would take care of all the Vaadin related configurations, for example ignoring the static resources, or to enable the `CSRF` checking while ignoring the unnecessary checking for Vaadin internal requests, etc.
- The View Based Authorization mechanism is enabled by default.
- The login view can be configured simply via provided method `setLoginView`.

.Never use hard-coded credentials in production
[NOTE]
By looking at the implementation of `userDetailsService` method, it is obvious that this is just an in-memory implementation for the sake of briefness in this documentation.
In a real-world application You can change the Spring Security configuration to use an authentication provider for LDAP, JAAS, and other real world sources. https://dzone.com/articles/spring-security-authentication[Read more about Spring Security authentication providers].

The most important configuration in the above example, is the call to the `setLoginView(http, LoginView.class);` inside the first configure method.
This is how the view based authorization mechanism knows where to redirect the users once they attempt to navigate to a protected view.

Now that the `LoginView` is ready, and it is set as the login view in the security configuration, it is time to move forward and see how the security annotations work on the views.

=== Annotating the View Classes

Before providing a usage examples of the access annotations, it would be beneficial to have a closer look at the annotations, and their meaning when applied on a view:

- `@AnonymousAllowed` Permits anyone to navigate to the view without any authentication or authorization.
- `@PermitAll` Allows any authenticated user to navigate to the view.
- `@RolesAllowed` Grants access to users having the roles specified in the annotation value.
- `@DenyAll` Disallows to navigate to the view for everyone.
This is the default, which means if a view is not annotated at all, the `@DenyAll` logic would be applied.

This should be highlighted that when the security configuration class is extending from `VaadinWebSecurityConfigurerAdapter`, Vaadin's `SpringSecurityAutoConfiguration` would come into play and *enables the View Based Authorization* mechanism.
Therefore, none of the views are accessible, until one of the above annotations (except the `@DenyAll`) is applied to them.

Some examples:

.Example of using @AnonymousAllowed to enable all users navigating to this view
[source,java]
----
@Route(value = "", layout = MainView.class)
@PageTitle("Public View")
@AnonymousAllowed
public class PublicView extends VerticalLayout {
    // ...
}
----

.Example of using @PermitAll to allow only authenticated users (with any role) navigating to this view
[source,java]
----
@Route(value = "private", layout = MainView.class)
@PageTitle("Private View")
@PermitAll
public class PrivateView extends VerticalLayout {
    // ...
}
----

.Example of using @RolesAllowed to enable only the users with `ADMIN` role navigating to this view
[source,java]
----
@Route(value = "admin", layout = MainView.class)
@PageTitle("Admin View")
@RolesAllowed("ADMIN") // <- Should match one of the user's roles (case-sensitive)
public class AdminView extends VerticalLayout {
    // ...
}
----

If multiple annotations specified on a single view, the following rules are applied:

- `DenyAll` overrides other annotations
- `AnonymousAllowed` overrides `RolesAllowed` and `PermitAll`
- `RolesAllowed` overrides `PermitAll`

However, specifying more than one of the above access annotations on a view class in not recommended, as it is confusing and probably has no logical reason to do so.

== Limitations
It is important to note that this View-Based Authorization mechanism should be considered as an alternative to the traditional Spring Security's pattern based `HttpSecurity` configurations that happened previously in Vaadin Spring Boot applications.
Mixing any of the view access annotations with `AntPathRequestMatcher` (which probably existing in older Vaadin Spring Boot applications) may result in unwanted access configurations or unnecessary complications.

.Do not mix Pattern-based HTTP security and View-based authorization
[NOTE]
Vaadin strongly recommends NOT to mix traditional Spring's Pattern-based HTTP security and this View-based authorization mechanism targeting same views, since it may lead to unwanted access configurations, or at least an unnecessary complication in the authorization of the views.

