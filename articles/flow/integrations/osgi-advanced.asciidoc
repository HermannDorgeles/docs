---
title: Advanced Using Vaadin with OSGi
order: 220
layout: page
---

[[osgi.advanced]]
= Advanced Using Vaadin with OSGi

Vaadin bundle being deployed to OSGi container may use any functionality provided by OSGi container via API.
It's not possible to use Declarative Services directly: Vaadin components (including navigation targets) are not declared as services.
But it's possible to use services via OSGi API which allows to use Decalrative Services indirectly.

[[osgi.advanced.services]]
== Using Services with Vaadin Components

OSGi provides a generic API which can be used everywhere to get a service:

[source, Java]
----
@Route("")
public class MainView extends Div {

    @Override
    protected void onAttach(AttachEvent attachEvent) {
        BundleContext bundleContext = FrameworkUtil.getBundle(getClass())
                .getBundleContext();
        ServiceReference<SomeService> reference = bundleContext
                .getServiceReference(SomeService.class);
        SomeService service = bundleContext.getService(reference);
        // do something with the service
    }

}
----

This code can be written in any class regardless the class nature: doesn't matter whether it's a `Component`, navigation target or just a helper class.

One thing is assumed here: the service `SomeService` is registered at the time when the component is attached.
It's developer responsibility to decide which fallback should be used if the service is not registered yet:

[source, Java]
----
protected void onAttach(AttachEvent attachEvent) {
    BundleContext bundleContext = FrameworkUtil.getBundle(getClass())
            .getBundleContext();
    ServiceReference<SomeService> reference = bundleContext
            .getServiceReference(SomeService.class);
    if (reference == null){
        // fallback to alternative action
    }
    else {
        SomeService service = bundleContext.getService(reference);
        // do something with the service
    }
}
----

It might be that the service is always registered at the point when it's requested (the application logic is written that way).
In this case there is no need to care about fallback. 
Otherwise it's necessary to handle this case specifically.

It's important to understand that in this case the route path `""` with navigation target `MainView` is available unconditionally:
regardless of `SomeService` presence the route is registered.

It might be there is no any point to provide a fallback when the service is not available: the route should not be even available in that case.
It is possible to handle such usecase as well but dynamic route registration should be used in this case.
Some boilerplate code is required to track the service and register a route when the service becomes available:


[source, Java]
----
@org.osgi.service.component.annotations.Component(service = Servlet.class)
@HttpWhiteboardServletAsyncSupported
@HttpWhiteboardServletPattern("/*")
public class FixedVaadinServlet extends OSGiVaadinServlet {

    private ServiceTracker<SomeService, SomeService> tracker;

    @Override
    protected void servletInitialized() throws ServletException {
        getService().setClassLoader(getClass().getClassLoader());

        VaadinServletContext servletContext = (VaadinServletContext) getService()
                .getContext();

        Bundle bundle = FrameworkUtil.getBundle(FixedVaadinServlet.class);
        tracker = new ServiceTracker<SomeService, SomeService>(
                bundle.getBundleContext(), SomeService.class, null) {
            @Override
            public SomeService addingService(
                    ServiceReference<SomeService> reference) {
                Bundle[] usingBundles = reference.getUsingBundles();
                if (usingBundles == null || usingBundles.length == 0) {
                    ApplicationRouteRegistry.getInstance(servletContext)
                            .setRoute("",SomeView.class,Collections.emptyList());
                }
                return super.addingService(reference);
            }

            @Override
            public void removedService(ServiceReference<SomeService> reference,
                    SomeService service) {
                Bundle[] usingBundles = reference.getUsingBundles();
                if (usingBundles != null && usingBundles.length == 1) {
                    ApplicationRouteRegistry.getInstance(servletContext)
                            .removeRoute("");
                }
                super.removedService(reference, service);
            }
        };
        tracker.open();

    }
    
    @Override
    public void destroy() {
        super.destroy();
        if (tracker != null) {
            tracker.close();
        }
    }

}

public class SomeView extends Div {
    // .....
}
----

The service tracker in this example registers the `SomeView` navigation target when service 
becomes available and unregisters the route when service is unregistered.

[NOTE]
The `SomeView` class in the example is not annotated with `@Route` at all. Otherwise it's considered as a static route and
will be registered unconditionally.

[[osgi.advanced.declarative.services]]
== Using Declarative Services with Vaadin Components

As it's said above: it not possible to use Declarative Services directly with Vaadin Components.
So the following example won't work:

[source, Java]
----
@Route("")
public class MainView extends Div {

    @Reference
    private SomeService service;

    @Override
    protected void onAttach(AttachEvent attachEvent) {
        // do something with the service
    }

}
----

As you may assume this would allow to avoid the boilerplate code to get a service programmatically
and necessity to make a fallback handler.

There are a number of reasons why this is not supported:
* There is no any way to make it properly work via OSGi Declarative Services: `MainView` needs to be a service by itself which requires quite error-prone boilerplate code: `@Component(scope=ServiceScope.PROTOTYPE, service=SomeDedicatedService.class)`
* It's extremely easy to make two mistakes in the `@Component` declaration: 
** the `scope` has to be prototype. Any other scope is invalid for the component. It's extremely easy to make a mistake here
** the `service` has to be a dedicated type. It could have been e.g. `HasElement`  but this is another easy way to make a mistake to forget specify the service at all.
* Such feature becomes self-contradictory and confusing: `@Route` makes a component registered statically/unconditionally in Flow.
But in OSGi having `MainView` as a service we may not register the route statically: it should be registered only when  `MainView` becomes available as a service
(which depends on `SomeService` service). So `@Route` semantic should have been changed in OSGi. But this is impossible (see the next item).
* Navigation target annotated with `@Route`  which is not an OSGi service should still work (it should be statically registered as a navigation target).
It is necessary to support regular usecase: web application which works without OSGi should work inside OSGi without any changes.
* If you want to use some OSGi lifecycle methods (like `activate`/`deactivate`) or other methods published via Declarative Services annotations you should be aware
that they are not called from the HTTP request dispatcher thread and it's necessary to use `UI::access` or `VaadinSession::access` to invoke
methods on UI objects. It's too easy to forget about this.

It's quite easy to modify the above example to use OSGi Declarative Services indirectly though:

[source, Java]
----
@Route("")
public class MainView extends Div {

    @Override
    protected void onAttach(AttachEvent attachEvent) {
       BundleContext bundleContext = FrameworkUtil.getBundle(getClass())
            .getBundleContext();
        ServiceReference<PairedOSGiService> reference = bundleContext
            .getServiceReference(PairedOSGiService.class);
        if (reference != null){
             bundleContext.getService(reference).setView(this);
        }
    }

}

@org.osgi.service.component.annotations.Component(scope=ServiceScope.PROTOTYPE, service=PairedOSGiService.class)
public class PairedOSGiService {

    @Reference
    private SomeService service;
    
    private AtomicReference<MainView> viewReference = new AtomicReference<>();
    
    void setView(MainView view){
       // store view to call its methods
       viewReference.set(view);
    }
    
    @Activate
    void activate(){
       MainView view = viewReference.get();
       if (view!= null && view.isAttached()){
           view.getUI().access( () -> {
                // mutate UI state
           });
       }
    }
}
----

In this example the `MainView` class is responsible for UI actions and `PairedOSGiService` 
is responsible for OSGi related functionality. The border is quite clear: every time when
OSGi wants mutate `UI` state it should call a command via `UI::access`.

You should be aware again about `PairedOSGiService` absence: if `SomeService` is not activated yet then `PairedOSGiService` won't be available as well.
Then fallback with a static route or dynamic route registration can be used as described above.

Technically the same approach may be used to mix OSGi services with Vaadin component if
OSGi logic and UI logic distinction is not suitable for some reasons: the navigation
target component can be just a wrapper for a service component:

[source, Java]
----
@Route("")
public class MainViewWrapper extends Div {

    private ServiceTracker<MainView, MainView> tracker;

    @Override
    protected void onAttach(AttachEvent attachEvent) {
        UI ui = attachEvent.getUI();
        Bundle bundle = FrameworkUtil.getBundle(MainView.class);
        tracker = new ServiceTracker<MainView, MainView>(
                bundle.getBundleContext(), MainView.class, null) {
            @Override
            public MainView addingService(
                    ServiceReference<MainView> reference) {
                Bundle[] usingBundles = reference.getUsingBundles();
                if (usingBundles == null || usingBundles.length == 0) {
                    ServiceObjects<MainView> serviceObjects = bundle
                            .getBundleContext().getServiceObjects(reference);
                    MainView view = serviceObjects.getService();
                    ui.access(() -> add(view));
                }
                return super.addingService(reference);
            }

            @Override
            public void removedService(ServiceReference<MainView> reference,
                    MainView service) {
                Bundle[] usingBundles = reference.getUsingBundles();
                if (usingBundles != null && usingBundles.length == 1) {
                    ui.access(MainViewWrapper.this::removeAll);
                }
                super.removedService(reference, service);
            }
        };
        tracker.open();
    }
    
    @Override
    protected void onDetach(DetachEvent detachEvent) {
        if (tracker!= null){
            tracker.close();
        }
    }

}

@org.osgi.service.component.annotations.Component(scope=ServiceScope.PROTOTYPE, service=MainView.class)
public class MainView extends Div {

    @Reference
    private SomeService service;
    
    @Override
    protected void onAttach(AttachEvent attachEvent) {
        // use the service
    }
    
    @Activate
    void activate() {
    }
    
}
----

So it's still possible to use a component as a Declarative Service but it requires
some boilerplate code which (on the other hand) allows to avoid mistakes.

The code in the example may work "on the fly": if the page is already opened in the browser
and service becomes available then the view will be updated automatically _if_ `Push` is used
in the project. Otherwise the browser needs to be refreshed to show the content of the `MainView`.

And as it has been discussed already above: if there is no point to show an empty navigation target page (as in the example) 
or some fallback component until the service is unavailable then the route may be registered dynamically
in the same way (and then there is no need to have tracker inside the `MainViewWrapper`): it's easy to 
see how to adapt the code for this case.

